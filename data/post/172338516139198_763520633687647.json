{"id":"172338516139198_763520633687647","from":{"id":"1037546276","name":"Shady Atef"},"to":{"data":[{"name":"Egyptian Geeks","id":"172338516139198"}]},"message":"I got kinda crazy idea\nIf I got 3 classes A B C\nClass A got methods foo & bar\nClass B,C extend A\n\nIf i want class B to only inherit  foo & class C to only inherit bar ..\nIs there any programming language support restrictions per inheritance ?","actions":[{"name":"Comment","link":"https://www.facebook.com/172338516139198/posts/763520633687647"},{"name":"Like","link":"https://www.facebook.com/172338516139198/posts/763520633687647"}],"privacy":{"value":""},"type":"status","created_time":"2014-06-12T21:46:01+0000","updated_time":"2014-06-13T07:34:26+0000","likes":{"data":[{"id":"699550407","name":"Mohamed Tarek El Haddad"},{"id":"1130162247","name":"Islam AbdelMohaimen Hassan"}],"paging":{"cursors":{"after":"MTEzMDE2MjI0Nw==","before":"Njk5NTUwNDA3"}}},"comments":{"data":[{"id":"763526760353701","from":{"id":"1055914266","name":"Hady Ahmad"},"message":"It's not crazy, I can think of a lot of cases where that's needed.\n\nYou're probably looking for traits and/or mixins. Some languages do support traits out of the box others build around mixins. Ruby uses mixins, Scala has beautiful support for traits (and behaviours)\n\nOthers like Rust, D (with an extension), Python (a package for traits), Javascript delegations and possibly quite a few others.\n\nYou might also want to look at the decorator pattern.","can_remove":true,"created_time":"2014-06-12T22:02:25+0000","like_count":3,"user_likes":false},{"id":"763528707020173","from":{"id":"1055914266","name":"Hady Ahmad"},"message":"But to answer your question, restrictions per inheritance? I don't think so. It'll be an anti pattern. The outcome you're describing is best achieved with trails/mixins.","can_remove":true,"created_time":"2014-06-12T22:06:50+0000","like_count":2,"user_likes":false},{"id":"763539627019081","from":{"id":"721605545","name":"Kareem Kashwaa"},"message":"If this is doable it would be considered a bad practice, I think the strategy pattern addresses this scenario","can_remove":true,"created_time":"2014-06-12T22:40:30+0000","like_count":0,"user_likes":false},{"id":"763549833684727","from":{"id":"1055914266","name":"Hady Ahmad"},"message":"Quite of a gray area, I was worried about this answer showing up Kareem Kashwaa\n\nThe similarities amongst decorator, strategy, presenter and composite are strikingly -and confusingly- similar\n\nNonetheless, the strategy pattern wont address the intended requirement of selective inheritance as per the intent of inheritance to begin with. Inheritance eventually extends the behavior of an object, it doesn't swap implementations and that's the intention of a strategy pattern.\n\nDecorators attach extra responsibilities to an object, hence dubbed an alternative to subclassing.\n\nIn layman's terms, if you're extending functionality then decorate, if you're replacing functionality then go for the strategy pattern. Inheritance whether selective or not, is a functionality extension tool.","message_tags":[{"id":"721605545","name":"Kareem Kashwaa","type":"user","offset":65,"length":14}],"can_remove":true,"created_time":"2014-06-12T23:12:28+0000","like_count":2,"user_likes":false},{"id":"763551973684513","from":{"id":"721605545","name":"Kareem Kashwaa"},"message":"I assumed replacement in the given scenario, where foo and bar are the algorithms that should replace each others, I quite agree with you nonetheless","can_remove":true,"created_time":"2014-06-12T23:19:01+0000","like_count":0,"user_likes":false},{"id":"763719757001068","from":{"id":"661261340","name":"Mohammad Tayseer"},"message":"I'm thinking of the concept itself. If you want to inherit foo but not bar, then both are two different things. In this case you should put foo in a class D & bar in a class E. B inherits D. C inherits E. A inherits D & E.\n\nThere languages which allows multiple inheritance (C++ & Python). Others implement it with mixins (Ruby).\n\nIn C#, you can get around this using interfaces + extension methods. To apply it to the above example: D & E will be interfaces, then you should create DeeExtensions containing an extension method foo & EeeExtensions containing extension method bar.\n\nWhat if you can't control A? You can make B inherit from it, then override bar to throw an NotImplementedException. If you're using a dynamic language (e.g. Python), you can remove the method from the class.","can_remove":true,"created_time":"2014-06-13T07:34:26+0000","like_count":1,"user_likes":false}],"paging":{"cursors":{"after":"NzYzNzE5NzU3MDAxMDY4","before":"NzYzNTI2NzYwMzUzNzAx"}}}}