{"id":"172338516139198_1095413573831683","from":{"name":"Mohamed Gamal","id":"10155052545932328"},"message":"Hello,\nI wrote this C implementation of the quick sort algorithm today. It works most of the time but sometimes I find a relatively small number embedded between two big ones..\nI believe there's something wrong in one very specific case, but I can't really figure it out.\nPlease check out the code and tell me if you find out something.\nThanks in advance.","story":"Mohamed Gamal shared a link to the group: Egyptian Geeks.","story_tags":{"0":[{"id":"10155052545932328","name":"Mohamed Gamal","type":"user","offset":0,"length":13}],"42":[{"id":"172338516139198","name":"Egyptian Geeks","type":"group","offset":42,"length":14}]},"link":"https://gist.github.com/JiMadness/0306568ecc5329d9e5d1","name":"Implementation of quick sort algorithm in C","caption":"gist.github.com","description":"Implementation of quick sort algorithm in C","icon":"https://www.facebook.com/images/icons/post.gif","actions":[{"name":"Comment","link":"https://www.facebook.com/172338516139198/posts/1095413573831683"},{"name":"Like","link":"https://www.facebook.com/172338516139198/posts/1095413573831683"},{"name":"Report Post to Admin","link":"https://www.facebook.com/groups/egyptian.geeks/members/"}],"privacy":{"value":"","description":"","friends":"","allow":"","deny":""},"type":"link","status_type":"shared_story","created_time":"2016-03-11T14:29:09+0000","updated_time":"2016-03-11T17:21:22+0000","is_hidden":false,"is_expired":false,"comments":{"data":[{"created_time":"2016-03-11T16:19:18+0000","from":{"name":"Mohamed Nabil","id":"10211669356036783"},"message":"Try this test case: {1,0,3,2}\n\nMaking the pivot 3 will make the algorithm ignore the existence of the last element, this happened because of this part.\nhttp://pastebin.com/Gp659VEH\nin the second while loop, when it goes in the first iteration it doesn't actually change the last element with the pivot, when the pivot+1 is the last element while doing the swapping part it doesn't swap them it keeps the array as it is which is wrong.\nDebugging\ntemp= 2 *pivot= 3 *(pivot+1)= 2 *last= 2\ntemp= 2 *pivot= 3 *(pivot+1)= 3 *last= 3\ntemp= 2 *pivot= 3 *(pivot+1)= 3 *last= 3\ntemp= 2 *pivot= 3 *(pivot+1)= 2 *last= 2\nso after this nothing changed in the array.\n\nTo fix the problem I added another if inside the previously mentioned if, it checks if the pivot+1 == last then it makes a normal swap otherwise it does the previous work.\nThe fixed code: http://pastebin.com/amGJmqVn\nAnother thing I commented this whole if \"if(*(pivot+1)<*pivot)\" http://pastebin.com/0xd4ZAAE the program's behaviour didn't change so I suspect it is a redundant code but I'm not sure.\n\nTry using small test cases instead of using random test cases generator, the first test case that I tried was very trivial {0, 1} and it failed directly.\nLastly, I don't recommend using such a code in anything, even after debugging it I'm not sure that it will work properly its very hard to trace or to find any bugs in it and the pointers are very irritating and confusing, try rewriting it again without the pointers I don't think it will produce much overhead in either time or memory.","can_remove":false,"like_count":2,"user_likes":false,"id":"1095465567159817"},{"created_time":"2016-03-11T16:46:41+0000","from":{"name":"Mohamed Gamal","id":"10155052545932328"},"message":"Thanks alot, it works now :D\nI know that using pointers wasn't a good idea. I haven't coded in C for about 6 months and I needed to have a quick revision on the syntax, pointers,etc ... so I challenged myself to implement that algorithm using pointers only :D","can_remove":false,"like_count":0,"user_likes":false,"id":"1095475990492108"}],"paging":{"cursors":{"before":"WTI5dGJXVnVkRjlqZAFhKemIzSTZANVEE1TlRRMk5UVTJOekUxT1RneE56b3hORFUzTnpFek1UWXcZD","after":"WTI5dGJXVnVkRjlqZAFhKemIzSTZANVEE1TlRRM05UazVNRFE1TWpFd09Eb3hORFUzTnpFME9EQXgZD"}}}}